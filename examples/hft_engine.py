import asyncio
import math
import os
import time
from collections import deque
import aiohttp
import orjson
import websockets
from dotenv import load_dotenv
from py_clob_client.client import ClobClient
from py_clob_client.clob_types import ApiCreds, BookParams, OrderArgs, OrderType
from py_clob_client.constants import POLYGON
from py_clob_client.exceptions import PolyApiException
from py_clob_client.order_builder.constants import BUY

load_dotenv()

# Strategy + risk knobs
MAX_SIZE = 10.0
MIN_SIZE = 1.0
SIZE_SIGMA = 50.0  # standard deviation for Gaussian decay
VELOCITY_THRESHOLD = 25.0
OBI_THRESHOLD = 0.6
SPREAD_THRESHOLD = 0.03
FAIR_VALUE_EPS = 0.02
DATA_STALENESS_S = 2.0
BOOK_REFRESH_S = 0.5
COOLDOWN_SECONDS = 5.0
# SET TO FALSE TO TRADE REAL MONEY
DRY_RUN_MODE = False
BINANCE_SYMBOL = os.getenv("BINANCE_SYMBOL", "BTCUSDT")
BINANCE_STREAM = os.getenv("BINANCE_STREAM", "btcusdt@bookTicker")
BINANCE_REF_PRICE_OVERRIDE = os.getenv("BINANCE_REF_PRICE_OVERRIDE")

# Global shared state for ultra-low latency execution
POLY_MARKET_CACHE = {
    "UP": {"id": None, "bid": 0.0, "ask": 0.0, "spread": 0.0, "last_updated": 0.0},
    "DOWN": {"id": None, "bid": 0.0, "ask": 0.0, "spread": 0.0, "last_updated": 0.0},
}
NEEDS_NEW_IDS = False
CACHE_LOCK = asyncio.Lock()
client: ClobClient | None = None
BINANCE_REF_PRICE = 0.0


class MarketState:
    """Keeps a small sliding window of mid-prices to measure velocity."""

    def __init__(self, maxlen: int = 20) -> None:
        self._prices = deque(maxlen=maxlen)  # (timestamp, price)
        self._lock = asyncio.Lock()

    async def update(self, price: float, ts: float) -> None:
        async with self._lock:
            self._prices.append((ts, price))

    async def velocity(self, window_s: float = 1.0) -> float:
        async with self._lock:
            if len(self._prices) < 2:
                return 0.0
            now = self._prices[-1][0]
            oldest_t, oldest_p = self._prices[0]
            for t, p in reversed(self._prices):
                if now - t <= window_s:
                    oldest_t, oldest_p = t, p
                else:
                    break
            newest_t, newest_p = self._prices[-1]
            dt = newest_t - oldest_t
            if dt <= 0:
                return 0.0
            return (newest_p - oldest_p) / dt


def calculate_obi(bid_qty: float, ask_qty: float) -> float:
    denom = bid_qty + ask_qty
    if denom == 0:
        return 0.0
    return (bid_qty - ask_qty) / denom


def calculate_size(price: float) -> float:
    dist = abs(price - BINANCE_REF_PRICE) if BINANCE_REF_PRICE else abs(price)
    size = MAX_SIZE * math.exp(-(dist**2) / (2 * SIZE_SIGMA**2))
    return max(MIN_SIZE, size)


async def get_binance_candle_open(session: aiohttp.ClientSession) -> float:
    """
    Async fetch of the latest 15m candle open price for sizing calibration.
    Retries with backoff until successful.
    """
    if BINANCE_REF_PRICE_OVERRIDE:
        print("‚ÑπÔ∏è Using BINANCE_REF_PRICE_OVERRIDE from env.")
        return float(BINANCE_REF_PRICE_OVERRIDE)

    url = (
        f"https://api.binance.com/api/v3/klines"
        f"?symbol={BINANCE_SYMBOL}&interval=15m&limit=1"
    )
    print("‚è≥ Fetching Binance reference price...")
    start_time = time.time()
    backoff = 1
    while True:
        try:
            async with session.get(url, timeout=10) as resp:
                resp.raise_for_status()
                data = await resp.json(loads=orjson.loads)
                if data and isinstance(data, list):
                    return float(data[0][1])
        except Exception as e:  # noqa: BLE001 - keep retrying loudly
            print(f"‚ö†Ô∏è Failed to fetch reference price: {e}. Retrying in {backoff}s...")
            await asyncio.sleep(backoff)
            backoff = min(backoff * 2, 10)
        if time.time() - start_time > 60:
            print("‚ö†Ô∏è Unable to fetch Binance reference price after 60s. Using 0.0.")
            return 0.0


async def refresh_market_ids() -> bool:
    """
    Reads IDs from active_ids.json (generated by your helper script).
    """
    global NEEDS_NEW_IDS

    file_path = "active_ids.json"

    if not os.path.exists(file_path):
        print(f"‚è≥ Waiting for {file_path}...")
        return False

    try:
        with open(file_path, "r") as f:
            data = orjson.loads(f.read())

        up_id = data.get("UP")
        down_id = data.get("DOWN")

        if not up_id or not down_id:
            return False

        async with CACHE_LOCK:
            if POLY_MARKET_CACHE["UP"]["id"] != up_id:
                print(f"üîÑ LOADED NEW MARKET: {data.get('market', 'Unknown')}")
                print(f"   UP: {up_id} | DOWN: {down_id}")

                POLY_MARKET_CACHE["UP"] = {"id": up_id, "bid": 0.0, "ask": 0.0, "spread": 0.0, "last_updated": 0.0}
                POLY_MARKET_CACHE["DOWN"] = {"id": down_id, "bid": 0.0, "ask": 0.0, "spread": 0.0, "last_updated": 0.0}

        NEEDS_NEW_IDS = False
        return True

    except Exception as e:
        print(f"‚ùå Error reading JSON: {e}")
        return False


def cache_has_ids() -> bool:
    return bool(POLY_MARKET_CACHE["UP"]["id"] and POLY_MARKET_CACHE["DOWN"]["id"])


def resolve_side_for_token(token_id: str) -> str | None:
    for label, entry in POLY_MARKET_CACHE.items():
        if entry["id"] == token_id:
            return label
    return None


async def polymarket_data_stream(poly_client: ClobClient) -> None:
    """
    Corrected Stream: Reads from the TAIL of the order book arrays
    because the API returns them sorted Worst-to-Best.
    """
    global NEEDS_NEW_IDS
    while True:
        if poly_client is None:
            await asyncio.sleep(1)
            continue

        if NEEDS_NEW_IDS or not cache_has_ids():
            await refresh_market_ids()
            await asyncio.sleep(1)
            continue

        try:
            params = [
                BookParams(token_id=POLY_MARKET_CACHE["UP"]["id"]),
                BookParams(token_id=POLY_MARKET_CACHE["DOWN"]["id"]),
            ]
            books = await asyncio.to_thread(poly_client.get_order_books, params)
        except Exception:
            await asyncio.sleep(BOOK_REFRESH_S)
            continue

        now = time.time()

        async with CACHE_LOCK:
            for book in books:
                label = resolve_side_for_token(book.asset_id)
                if not label:
                    continue

                has_bids = len(book.bids) > 0
                has_asks = len(book.asks) > 0

                # Bids are sorted 0.01 -> higher. We want the LAST one (Highest).
                best_bid = float(book.bids[-1].price) if has_bids else 0.0

                # Asks are sorted 0.99 -> lower. We want the LAST one (Lowest).
                best_ask = float(book.asks[-1].price) if has_asks else 0.0

                # Calculate Spread
                if has_bids and has_asks:
                    spread = best_ask - best_bid
                else:
                    spread = 999.0

                # Sanity Check: If spread is negative (crossed book), assume tradeable at ask
                if spread < 0:
                    spread = 0.0

                POLY_MARKET_CACHE[label].update(
                    {
                        "id": book.asset_id,
                        "bid": best_bid,
                        "ask": best_ask,
                        "spread": spread,
                        "last_updated": now,
                    }
                )

        await asyncio.sleep(BOOK_REFRESH_S)


async def execute_trade(signal: str, size: float) -> None:
    global NEEDS_NEW_IDS
    if client is None:
        print("‚ùå Client not initialized")
        return

    side_label = "UP" if signal.upper().startswith("BULL") or signal.upper() == "UP" else "DOWN"
    async with CACHE_LOCK:
        up_entry = POLY_MARKET_CACHE["UP"].copy()
        down_entry = POLY_MARKET_CACHE["DOWN"].copy()

    target = up_entry if side_label == "UP" else down_entry
    other = down_entry if side_label == "UP" else up_entry

    if NEEDS_NEW_IDS or not target["id"]:
        print("‚ö†Ô∏è Skipping trade: market IDs unresolved.")
        return

    now = time.time()
    if now - target["last_updated"] >= DATA_STALENESS_S:
        print("‚ùå Stale Polymarket book; no trade sent.")
        return

    if target["spread"] >= SPREAD_THRESHOLD:
        print(f"‚ùå Spread guard tripped ({target['spread']:.4f}); aborting.")
        return

    if target["ask"] <= 0 or other["bid"] <= 0:
        print("‚ùå Missing top-of-book data; aborting.")
        return

    parity = up_entry["ask"] + down_entry["bid"]
    if abs(parity - 1.0) > FAIR_VALUE_EPS:
        print("‚ùå Parity check failed (UP ask + DOWN bid not ‚âà 1).")
        return

    price = target["ask"]
    if DRY_RUN_MODE:
        print(
            f"üîß DRY RUN: BUY {side_label} {size:.2f} @ ${price:.4f} "
            f"(spread {target['spread']:.4f})"
        )
        return

    try:
        order_args = OrderArgs(
            price=price,
            size=size,
            side=BUY,
            token_id=target["id"],
        )
        signed_order = await asyncio.to_thread(client.create_order, order_args)
        resp = await asyncio.to_thread(client.post_order, signed_order, OrderType.FAK)
        order_id = resp.get("orderID") if isinstance(resp, dict) else resp
        print(f"‚úÖ Sent BUY {side_label} | OrderID: {order_id}")
    except PolyApiException as e:
        if e.status_code == 404:
            NEEDS_NEW_IDS = True
        print(f"‚ùå Order error: {e}")
    except Exception as e:  # noqa: BLE001
        print(f"‚ùå Unexpected order error: {e}")


async def market_data_listener(state: MarketState) -> None:
    url = f"wss://stream.binance.com/ws/{BINANCE_STREAM}"
    backoff = 1
    last_trigger_time = 0.0

    while True:
        try:
            async with websockets.connect(
                url,
                ping_interval=15,
                ping_timeout=15,
                max_queue=1,
            ) as ws:
                backoff = 1
                print("‚ö° Connected to Binance...")
                async for msg in ws:
                    data = orjson.loads(msg)
                    bid = float(data["b"])
                    ask = float(data["a"])
                    bid_qty = float(data["B"])
                    ask_qty = float(data["A"])
                    mid = (bid + ask) / 2.0
                    ts = time.time()
                    await state.update(mid, ts)

                    if ts - last_trigger_time < COOLDOWN_SECONDS or NEEDS_NEW_IDS:
                        continue

                    vel = await state.velocity(window_s=1.0)
                    obi = calculate_obi(bid_qty, ask_qty)
                    size = calculate_size(mid)

                    if vel > VELOCITY_THRESHOLD and obi > OBI_THRESHOLD:
                        print(
                            f"üö® BULL SIGNAL! Vel: {vel:.2f} | Size: {size:.2f} | OBI: {obi:.2f}"
                        )
                        last_trigger_time = ts
                        await execute_trade("UP", size)
                    elif vel < -VELOCITY_THRESHOLD and obi < -OBI_THRESHOLD:
                        print(
                            f"üö® BEAR SIGNAL! Vel: {vel:.2f} | Size: {size:.2f} | OBI: {obi:.2f}"
                        )
                        last_trigger_time = ts
                        await execute_trade("DOWN", size)
        except Exception as e:  # noqa: BLE001
            print(f"MD connection error: {e} | reconnecting in {backoff}s")
            await asyncio.sleep(backoff)
            backoff = min(backoff * 2, 30)


async def main() -> None:
    global BINANCE_REF_PRICE, client

    host = os.getenv("CLOB_API_URL") or "https://clob.polymarket.com"
    key = os.getenv("PK")
    sig_type = int(os.getenv("SIGNATURE_TYPE", "1"))
    funder = os.getenv("FUNDER")
    chain_id = int(os.getenv("CHAIN_ID", str(POLYGON)))

    creds = None
    api_key = os.getenv("CLOB_API_KEY")
    api_secret = os.getenv("CLOB_SECRET")
    api_passphrase = os.getenv("CLOB_PASS_PHRASE")
    if api_key and api_secret and api_passphrase:
        creds = ApiCreds(
            api_key=api_key,
            api_secret=api_secret,
            api_passphrase=api_passphrase,
        )

    client = ClobClient(
        host,
        key=key,
        chain_id=chain_id,
        signature_type=sig_type,
        funder=funder,
        creds=creds,
    )

    if creds:
        print("‚úÖ Polymarket client initialized with API creds")
    else:
        print("‚ÑπÔ∏è Polymarket client initialized without API creds (read-only)")

    async with aiohttp.ClientSession(json_serialize=orjson.dumps) as session:
        BINANCE_REF_PRICE = await get_binance_candle_open(session)
        print(f"‚úÖ Reference Price set to: ${BINANCE_REF_PRICE:,.2f}")

    await refresh_market_ids()

    state = MarketState(maxlen=20)
    asyncio.create_task(polymarket_data_stream(client))
    await market_data_listener(state)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
